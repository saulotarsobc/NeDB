"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

var _ = require('lodash');

var formatParamOutput = require('./format-param-output');

var persistValues = require('./persist-values');

module.exports = function (req, context) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var allFields = [];
  var optionalityFilter = options.filterOptionals == null || options.filterOptionals ? createOptionalityFilter(context) : Boolean;
  var sanitizerMapper = createSanitizerMapper(req, context, options);
  context.fields.map(function (field) {
    return field == null ? '' : field;
  }).forEach(function (field) {
    var instances = _(context.locations).flatMap(createFieldExpander(req, field)).map(sanitizerMapper).filter(optionalityFilter).value(); // #331 - When multiple locations are involved, all of them must pass the validation.
    // If none of the locations contain the field, we at least include one for error reporting.
    // #458, #531 - Wildcards are an exception though: they may yield 0..* instances with different
    // paths, so we may want to skip this filtering.


    if (instances.length > 1 && context.locations.length > 1 && !field.includes('*')) {
      var withValue = instances.filter(function (field) {
        return field.value !== undefined;
      });
      instances = withValue.length ? withValue : [instances[0]];
    }

    allFields = allFields.concat(instances);
  });
  persistValues(req, allFields);
  return _.uniqWith(allFields, _.isEqual);
};

function createFieldExpander(req, field) {
  return function (location) {
    var fieldPath = location === 'headers' ? field.toLowerCase() : field;
    return expand(req[location], fieldPath, []).map(function (path) {
      return {
        location: location,
        path: path,
        value: path === '' ? req[location] : _.get(req[location], path)
      };
    }).map(function (field) {
      return Object.assign(field, {
        originalValue: field.value
      });
    });
  };
}

function expand(object, path, paths) {
  var segments = _.toPath(path);

  var wildcard = segments.indexOf('*');

  if (wildcard > -1) {
    var subObject = wildcard ? _.get(object, segments.slice(0, wildcard)) : object;

    if (!subObject) {
      return paths;
    }

    Object.keys(subObject).map(function (key) {
      return segments.slice(0, wildcard).concat(key).concat(segments.slice(wildcard + 1));
    }).forEach(function (path) {
      return expand(object, path, paths);
    });
  } else {
    paths.push(formatParamOutput(segments));
  }

  return paths;
}

function createSanitizerMapper(req, _ref, _ref2) {
  var _ref$sanitizers = _ref.sanitizers,
      sanitizers = _ref$sanitizers === void 0 ? [] : _ref$sanitizers;
  var _ref2$sanitize = _ref2.sanitize,
      sanitize = _ref2$sanitize === void 0 ? true : _ref2$sanitize;
  return !sanitize ? function (field) {
    return field;
  } : function (field) {
    return sanitizers.reduce(function (prev, sanitizer) {
      var value = typeof prev.value === 'string' ? callSanitizer(sanitizer, prev) : prev.value;
      return Object.assign({}, prev, {
        value: value
      });
    }, field);
  };

  function callSanitizer(config, field) {
    return !config.custom ? config.sanitizer.apply(config, [field.value].concat(_toConsumableArray(config.options))) : config.sanitizer(field.value, {
      req: req,
      location: field.location,
      path: field.path
    });
  }
}

function createOptionalityFilter(_ref3) {
  var optional = _ref3.optional;
  var checks = [function (value) {
    return value !== undefined;
  }, function (value) {
    return optional.nullable ? value != null : true;
  }, function (value) {
    return optional.checkFalsy ? value : true;
  }];
  return function (field) {
    if (!optional) {
      return true;
    }

    return checks.every(function (check) {
      return check(field.value);
    });
  };
}