"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

var _require = require('../utils/filters'),
    isValidator = _require.isValidator;

var check = require('./check');

var validLocations = ['body', 'cookies', 'headers', 'params', 'query'];
var notValidators = ['errorMessage', 'in'];

module.exports = function (schema) {
  var defaultLocations = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : validLocations;
  var chainCreator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : check;
  return Object.keys(schema).map(function (field) {
    var config = schema[field];
    var chain = chainCreator(field, ensureLocations(config, defaultLocations), config.errorMessage);
    Object.keys(config).filter(function (method) {
      return config[method] && !notValidators.includes(method);
    }).forEach(function (method) {
      if (typeof chain[method] !== 'function') {
        console.warn("express-validator: a validator with name ".concat(method, " does not exist"));
        return;
      }

      var methodCfg = config[method];
      var options = methodCfg.options || [];

      if (options != null && !Array.isArray(options)) {
        options = [options];
      }

      var methodIsValidator = isValidator(method) || method === 'custom' || method === 'exists';
      methodIsValidator && methodCfg.negated && chain.not();
      chain[method].apply(chain, _toConsumableArray(options));
      methodIsValidator && chain.withMessage(methodCfg.errorMessage);
    });
    return chain;
  });
};

function ensureLocations(config, defaults) {
  var locations = (Array.isArray(config["in"]) ? config["in"] : [config["in"]]).filter(Boolean);
  var actualLocations = locations.length ? locations : defaults;
  return actualLocations.filter(function (location) {
    return validLocations.includes(location);
  });
}