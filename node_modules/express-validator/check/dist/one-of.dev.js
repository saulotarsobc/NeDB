"use strict";

var _ = require('lodash');

var runner = require('./runner');

module.exports = function (validationChains, message) {
  return function (req, res, next) {
    var run = function run(chain) {
      return runner(req, getContext(chain));
    };

    var contexts = _.flatMap(validationChains, function (chain) {
      return Array.isArray(chain) ? chain.map(getContext) : getContext(chain);
    });

    var promises = validationChains.map(function (chain) {
      var group = Array.isArray(chain) ? chain : [chain];
      return Promise.all(group.map(run)).then(function (results) {
        return _.flatten(results);
      });
    });
    return Promise.all(promises).then(function (results) {
      req._validationContexts = (req._validationContexts || []).concat(contexts);
      req._validationErrors = req._validationErrors || [];
      var failedGroupContexts = findFailedGroupContexts(results, validationChains);
      req._validationOneOfFailures = (req._validationOneOfFailures || []).concat(failedGroupContexts);
      var empty = results.some(function (result) {
        return result.length === 0;
      });

      if (!empty) {
        req._validationErrors.push({
          param: '_error',
          msg: getDynamicMessage(message || 'Invalid value(s)', req),
          nestedErrors: _.flatten(results, true)
        });
      }

      next();
      return results;
    })["catch"](next);
  };
};

function getContext(chain) {
  return chain._context;
}

function findFailedGroupContexts(results, validationChains) {
  return _(results) // If the group is free of errors, the empty array plays the trick of filtering such group.
  .flatMap(function (result, index) {
    return result.length > 0 ? validationChains[index] : [];
  }).map(getContext).value();
}

function getDynamicMessage(message, req) {
  if (typeof message !== 'function') {
    return message;
  }

  return message({
    req: req
  });
}